#!/usr/bin/env node

import { glob } from 'glob';
import path from 'path';
import { XanoScriptValidator } from '../lib/validator.js';
import { formatHumanReadable, formatJSON, formatFileProgress } from '../lib/formatters.js';

/**
 * XanoScript Lint CLI
 * Validates .xs files using the XanoScript Language Server
 */

async function main() {
  const args = process.argv.slice(2);

  // Parse command line arguments
  const options = {
    files: [],
    format: 'readable', // 'readable' or 'json'
    serverPath: null,
    quiet: false,
    help: false,
    stdin: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '--help' || arg === '-h') {
      options.help = true;
    } else if (arg === '--json') {
      options.format = 'json';
    } else if (arg === '--server' && i + 1 < args.length) {
      options.serverPath = args[++i];
    } else if (arg === '--quiet' || arg === '-q') {
      options.quiet = true;
    } else if (arg === '--stdin') {
      options.stdin = true;
    } else if (!arg.startsWith('-')) {
      options.files.push(arg);
    } else {
      console.error(`Unknown option: ${arg}`);
      process.exit(1);
    }
  }

  // Show help
  if (options.help) {
    showHelp();
    process.exit(0);
  }

  if (options.stdin) {
    try {
      const stdinFiles = await readFilesFromStdin();
      options.files.push(...stdinFiles);
    } catch (err) {
      console.error('Error reading file list from stdin:', err.message);
      process.exit(1);
    }
  }

  // Find files to validate
  let filesToValidate = [];

  if (options.files.length === 0) {
    // No files specified - find all .xs files in current directory
    try {
      filesToValidate = await glob('**/*.xs', {
        ignore: ['**/node_modules/**', '**/.git/**', '**/dist/**', '**/build/**'],
        absolute: false
      });
    } catch (err) {
      console.error('Error finding .xs files:', err.message);
      process.exit(1);
    }

    if (filesToValidate.length === 0) {
      if (!options.quiet) {
        console.log('No .xs files found in current directory');
      }
      process.exit(0);
    }
  } else {
    // Expand glob patterns in provided files
    for (const pattern of options.files) {
      try {
        const matches = await glob(pattern, {
          ignore: ['**/node_modules/**', '**/.git/**'],
          absolute: false
        });

        if (matches.length === 0) {
          // Try as literal file path
          filesToValidate.push(pattern);
        } else {
          filesToValidate.push(...matches);
        }
      } catch (err) {
        console.error(`Error processing pattern "${pattern}":`, err.message);
        process.exit(1);
      }
    }
  }

  // Remove duplicates
  filesToValidate = [...new Set(filesToValidate)];

  if (filesToValidate.length === 0) {
    if (!options.quiet) {
      console.log('No files to validate');
    }
    process.exit(0);
  }

  // Start validation
  const validator = new XanoScriptValidator(options.serverPath);

  try {
    // Start the LSP server
    if (!options.quiet && options.format !== 'json') {
      process.stderr.write('Starting XanoScript Language Server...\n');
    }

    await validator.start();

    if (!options.quiet && options.format !== 'json') {
      process.stderr.write(`Found ${filesToValidate.length} file${filesToValidate.length !== 1 ? 's' : ''} to validate\n\n`);
    }

    // Validate each file
    for (let i = 0; i < filesToValidate.length; i++) {
      const file = filesToValidate[i];

      if (!options.quiet && options.format !== 'json') {
        const progress = formatFileProgress(file, i + 1, filesToValidate.length);
        process.stderr.write(`\r${progress}`);
      }

      await validator.validateFile(file);
    }

    if (!options.quiet && options.format !== 'json') {
      process.stderr.write('\r' + ' '.repeat(80) + '\r'); // Clear progress line
    }

    // Get results
    const results = validator.results;
    const summary = validator.getSummary();

    // Output results
    if (options.format === 'json') {
      console.log(formatJSON(results, summary));
    } else {
      console.log(formatHumanReadable(results, summary));
    }

    // Shutdown
    await validator.shutdown();

    // Exit with appropriate code
    process.exit(summary.hasErrors ? 1 : 0);

  } catch (err) {
    console.error('\nâŒ Error:', err.message);

    // Try to shutdown gracefully
    try {
      await validator.shutdown();
    } catch (shutdownErr) {
      // Ignore shutdown errors
    }

    process.exit(1);
  }
}

/**
 * Show help message
 */
function showHelp() {
  console.log(`
XanoScript Lint - Validate .xs files using the XanoScript Language Server

USAGE:
  xs-lint [OPTIONS] [FILES...]

OPTIONS:
  --help, -h       Show this help message
  --json           Output results as JSON
  --stdin          Read newline-separated file paths from stdin
  --quiet, -q      Suppress progress messages
  --server PATH    Path to LSP server.js (auto-detected if not specified)

EXAMPLES:
  # Validate all .xs files in current directory
  xs-lint

  # Validate specific files
  xs-lint src/api/users.xs src/api/posts.xs

  # Validate files matching pattern
  xs-lint "src/api/**/*.xs"

  # Output as JSON
  xs-lint --json

  # Specify custom server path
  xs-lint --server /path/to/server.js

EXIT CODES:
  0  No errors found
  1  Errors found or validation failed

For more information, visit: https://github.com/yourusername/xano-lsp-cli
`);
}

/**
 * Read newline-separated file paths from stdin.
 * Returns empty array immediately when running in a TTY without piped input.
 */
async function readFilesFromStdin() {
  if (process.stdin.isTTY) {
    return [];
  }

  return new Promise((resolve, reject) => {
    let data = '';
    process.stdin.setEncoding('utf8');

    process.stdin.on('data', chunk => {
      data += chunk;
    });

    process.stdin.on('end', () => {
      const files = data
        .split(/\r?\n/)
        .map(line => line.trim())
        .filter(Boolean);
      resolve(files);
    });

    process.stdin.on('error', err => {
      reject(err);
    });
  });
}

// Run the CLI
main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});
