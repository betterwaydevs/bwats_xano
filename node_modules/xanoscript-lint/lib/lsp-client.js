import { spawn } from "child_process";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
import fs from "fs";
import os from "os";

/**
 * LSP Client for XanoScript Language Server
 * Communicates via JSON-RPC over stdio
 */
export class XanoScriptLSPClient {
  constructor(serverPath = null) {
    this.serverPath = serverPath || this.findServerPath();
    this.process = null;
    this.messageId = 0;
    this.responseHandlers = new Map();
    this.diagnosticsMap = new Map();
    this.initialized = false;
    this.buffer = "";
  }

  /**
   * Auto-detect XanoScript LSP server path from VS Code extensions
   */
  findServerPath() {
    const vscodeExtDir = join(os.homedir(), ".vscode", "extensions");

    if (!fs.existsSync(vscodeExtDir)) {
      throw new Error(
        "VS Code extensions directory not found. Please install the XanoScript VS Code extension or specify --server path"
      );
    }

    // Look for xano.xanoscript extension (latest version)
    const extensions = fs.readdirSync(vscodeExtDir);
    const xanoExt = extensions
      .filter((ext) => ext.startsWith("xano.xanoscript-"))
      .sort((a, b) => b.localeCompare(a))[0];
    //console.log(xanoExt);

    if (!xanoExt) {
      throw new Error(
        "XanoScript extension not found. Please install it from VS Code marketplace or specify --server path"
      );
    }

    // Try dist/server.js first (compiled version), then fallback to language-server/server.js
    const distServerPath = join(vscodeExtDir, xanoExt, "dist", "server.js");
    const langServerPath = join(
      vscodeExtDir,
      xanoExt,
      "language-server",
      "server.js"
    );

    if (fs.existsSync(distServerPath)) {
      return distServerPath;
    } else if (fs.existsSync(langServerPath)) {
      return langServerPath;
    } else {
      throw new Error(
        `Server file not found at ${distServerPath} or ${langServerPath}`
      );
    }
  }

  /**
   * Start the LSP server process
   */
  async start() {
    return new Promise((resolve, reject) => {
      const serverDir = dirname(this.serverPath);

      // Spawn the Node.js process running the LSP server
      // Set cwd to the language-server directory so relative imports work
      this.process = spawn("node", [this.serverPath, "--stdio"], {
        stdio: ["pipe", "pipe", "pipe"],
        cwd: serverDir,
        env: {
          ...process.env,
          NODE_PATH: join(serverDir, "node_modules"),
        },
      });

      // Handle server errors
      this.process.on("error", (error) => {
        reject(new Error(`Failed to start LSP server: ${error.message}`));
      });

      // Handle server stderr (log warnings/errors but don't fail)
      this.process.stderr.on("data", (data) => {
        const message = data.toString();
        // Only log errors, not regular console output
        if (message.includes("Error") || message.includes("error")) {
          console.error(`LSP Server: ${message}`);
        }
      });

      // Handle server stdout (LSP messages)
      this.process.stdout.on("data", (data) => {
        this.handleData(data);
      });

      // Initialize and resolve when ready
      this.initialize().then(resolve).catch(reject);
    });
  }

  /**
   * Handle incoming data from LSP server
   */
  handleData(data) {
    this.buffer += data.toString();

    // Parse complete LSP messages
    while (true) {
      const headerEnd = this.buffer.indexOf("\r\n\r\n");
      if (headerEnd === -1) break;

      const header = this.buffer.slice(0, headerEnd);
      const contentLengthMatch = header.match(/Content-Length: (\d+)/);

      if (!contentLengthMatch) {
        this.buffer = this.buffer.slice(headerEnd + 4);
        continue;
      }

      const contentLength = parseInt(contentLengthMatch[1]);
      const messageStart = headerEnd + 4;

      if (this.buffer.length < messageStart + contentLength) break;

      const messageContent = this.buffer.slice(
        messageStart,
        messageStart + contentLength
      );
      this.buffer = this.buffer.slice(messageStart + contentLength);

      try {
        const message = JSON.parse(messageContent);
        this.handleMessage(message);
      } catch (err) {
        console.error("Failed to parse LSP message:", err);
      }
    }
  }

  /**
   * Handle parsed LSP message
   */
  handleMessage(message) {
    // Handle responses to our requests
    if (message.id !== undefined && this.responseHandlers.has(message.id)) {
      const handler = this.responseHandlers.get(message.id);
      this.responseHandlers.delete(message.id);

      if (message.error) {
        handler.reject(
          new Error(message.error.message || "LSP request failed")
        );
      } else {
        handler.resolve(message.result);
      }
      return;
    }

    // Handle server notifications
    if (message.method === "textDocument/publishDiagnostics") {
      this.diagnosticsMap.set(message.params.uri, message.params.diagnostics);
    }
  }

  /**
   * Send LSP request and wait for response
   */
  sendRequest(method, params) {
    const id = this.messageId++;
    const message = {
      jsonrpc: "2.0",
      id,
      method,
      params,
    };

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.responseHandlers.delete(id);
        reject(new Error(`Request timeout: ${method}`));
      }, 10000); // 10 second timeout

      this.responseHandlers.set(id, {
        resolve: (result) => {
          clearTimeout(timeout);
          resolve(result);
        },
        reject: (error) => {
          clearTimeout(timeout);
          reject(error);
        },
      });

      this.writeMessage(message);
    });
  }

  /**
   * Send LSP notification (no response expected)
   */
  sendNotification(method, params) {
    const message = {
      jsonrpc: "2.0",
      method,
      params,
    };

    this.writeMessage(message);
  }

  /**
   * Write message to server stdin
   */
  writeMessage(message) {
    const content = JSON.stringify(message);
    const header = `Content-Length: ${Buffer.byteLength(content)}\r\n\r\n`;
    this.process.stdin.write(header + content);
  }

  /**
   * Initialize LSP connection
   */
  async initialize() {
    const rootUri = `file://${process.cwd()}`;

    const result = await this.sendRequest("initialize", {
      processId: process.pid,
      rootUri,
      rootPath: process.cwd(),
      capabilities: {
        textDocument: {
          synchronization: {
            didOpen: true,
            didChange: true,
            didClose: true,
          },
        },
      },
      initializationOptions: {},
    });

    this.sendNotification("initialized", {});
    this.initialized = true;

    return result;
  }

  /**
   * Validate a single file
   */
  async validateFile(filePath, content) {
    const uri = `file://${filePath}`;

    // Clear previous diagnostics
    this.diagnosticsMap.delete(uri);

    // Open document
    this.sendNotification("textDocument/didOpen", {
      textDocument: {
        uri,
        languageId: "xanoscript",
        version: 1,
        text: content,
      },
    });

    // Trigger validation by sending didChange
    this.sendNotification("textDocument/didChange", {
      textDocument: {
        uri,
        version: 2,
      },
      contentChanges: [
        {
          text: content,
        },
      ],
    });

    // Wait for diagnostics to be published
    await this.waitForDiagnostics(uri, 2000);

    // Close document
    this.sendNotification("textDocument/didClose", {
      textDocument: { uri },
    });

    return this.diagnosticsMap.get(uri) || [];
  }

  /**
   * Wait for diagnostics to arrive
   */
  waitForDiagnostics(uri, timeout = 2000) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const checkInterval = setInterval(() => {
        if (this.diagnosticsMap.has(uri) || Date.now() - startTime > timeout) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
    });
  }

  /**
   * Get completions at a specific position
   */
  async getCompletions(filePath, content, line, character) {
    const uri = `file://${filePath}`;

    // Open document
    this.sendNotification("textDocument/didOpen", {
      textDocument: {
        uri,
        languageId: "xanoscript",
        version: 1,
        text: content,
      },
    });

    // Request completions
    const completions = await this.sendRequest("textDocument/completion", {
      textDocument: { uri },
      position: { line, character },
    });

    // Close document
    this.sendNotification("textDocument/didClose", {
      textDocument: { uri },
    });

    return completions;
  }

  /**
   * Get hover information at a specific position
   */
  async getHover(filePath, content, line, character) {
    const uri = `file://${filePath}`;

    // Open document
    this.sendNotification("textDocument/didOpen", {
      textDocument: {
        uri,
        languageId: "xanoscript",
        version: 1,
        text: content,
      },
    });

    // Request hover info
    const hover = await this.sendRequest("textDocument/hover", {
      textDocument: { uri },
      position: { line, character },
    });

    // Close document
    this.sendNotification("textDocument/didClose", {
      textDocument: { uri },
    });

    return hover;
  }

  /**
   * Shutdown the LSP server
   */
  async shutdown() {
    if (this.initialized) {
      try {
        await this.sendRequest("shutdown", null);
        this.sendNotification("exit", null);
      } catch (err) {
        // Ignore shutdown errors
      }
    }

    if (this.process) {
      this.process.kill();
    }
  }
}
